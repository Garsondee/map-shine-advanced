# Fog of War Implementation Plan (Three.js)

## 1. Overview
We will replace Foundry VTT's default PIXI-based Fog of War (FoW) with a high-performance Three.js implementation integrated into the Map Shine Advanced rendering pipeline. The system mimics Foundry's logic (Unexplored vs. Explored vs. Visible) but leverages our 2.5D architecture.

## 2. Core Architecture

The FoW system consists of three main distinct layers/masks:
1.  **Vision Mask (Real-time)**: Represents what is currently visible (Lights + Token Vision).
2.  **Exploration Mask (Persistent)**: Represents what has been seen before (saved state).
3.  **Fog Composite**: A shader pass that combines the Scene, Vision, and Exploration masks to render the final output.

### Data Flow
```
[Foundry Data]
      |
      v
[VisionSource / LightSource] -> [LOS Polygon]
      |
      v
[VisionRenderPass] -> (Render to Texture R8) -> [VisionTarget]
                                                      |
                                                      v
                                              [ExplorationManager]
                                              (Accumulate Vision)
                                                      |
                                                      v
                                              [ExplorationTarget] (Persistent R8)
```

## 3. Components

### 3.1. VisionManager
Responsible for generating the current frame's visibility mask.

*   **Input**: `canvas.effects.visionSources`, `canvas.effects.lightSources`
*   **Process**:
    1.  Iterate over all active sources.
    2.  Retrieve the `source.los` (PIXI.Polygon) generated by Foundry's wall computation.
    3.  Triangulate these polygons into `THREE.BufferGeometry`.
    4.  Render these meshes into an off-screen `THREE.WebGLRenderTarget` (Red channel only).
    5.  Apply a slight blur (optional, for soft edges).
*   **Output**: `visionTexture` (Texture)

### 3.2. ExplorationManager
Responsible for the persistent "memory" of what has been seen.

*   **Input**: `visionTexture` (from VisionManager).
*   **State**: `explorationTexture` (Persistent `WebGLRenderTarget`).
*   **Process**:
    *   **Update**: When vision changes (or periodically), draw the `visionTexture` *on top* of the `explorationTexture` using `MAX` blending (keep the brightest value, i.e., if it was 0 and becomes 1, it stays 1).
    *   **Save**: Extract pixels from `explorationTexture` -> Base64 -> `FogExploration` document (mimicking `FogManager.save`).
    *   **Load**: `FogExploration` document -> Base64 -> Texture -> Draw to `explorationTexture`.
*   **Sync**: Must respect `resetFog` and other socket events.

### 3.3. FogShader (Compositor)
The shader that applies the visual effect.

*   **Uniforms**:
    *   `tScene`: The rendered map scene.
    *   `tVision`: The current `visionTexture`.
    *   `tExplored`: The persistent `explorationTexture`.
    *   `uUnexploredColor`: Color/Opacity for unexplored areas (usually black).
    *   `uExploredColor`: Color/Opacity for explored but not visible areas (dim/desaturated).
    *   `uSoftness`: Edge softness factor.
*   **Logic**:
    ```glsl
    float vision = texture2D(tVision, uv).r;
    float explored = texture2D(tExplored, uv).r;
    
    vec4 sceneColor = texture2D(tScene, uv);
    
    // Calculate visibility factor
    // 0.0 = Unexplored
    // 0.5 = Explored (Foggy)
    // 1.0 = Visible
    
    vec4 finalColor = sceneColor;
    
    if (vision > 0.5) {
        // Fully visible - no change
    } else if (explored > 0.5) {
        // Explored - Apply tint/dimming
        finalColor = mix(sceneColor, uExploredColor, 0.7); 
    } else {
        // Unexplored - Apply darkness
        finalColor = uUnexploredColor;
    }
    ```

## 4. Implementation Steps

### Step 1: Polygon to Mesh Conversion
Create a utility to convert `PIXI.Polygon` (Foundry's LOS) to `THREE.Shape` -> `THREE.ShapeGeometry` or raw `THREE.BufferGeometry` (using Earcut or similar, usually Foundry has `PIXI.utils.earcut`).
*   *Note*: Foundry's `source.los` is already a polygon. We need to map Foundry coords (pixels, top-left) to Three.js coords (world, center).

### Step 2: The Vision Pass
Create a separate `THREE.Scene` for vision.
*   On every frame (or when `canvas.perception.update` fires), rebuild meshes for all sources.
*   Render this scene to `visionRenderTarget`.

### Step 3: The Exploration Pass
Create a "ping-pong" or additive rendering setup.
*   Use a `Mesh` with the `visionRenderTarget` texture.
*   Render it into the `explorationRenderTarget` with `blending: THREE.CustomBlending`, `blendEquation: THREE.MaxEquation`. This ensures we only *add* visibility, never remove it (unless resetting).

### Step 4: Integration with EffectComposer
Add a `FogPass` to our main `EffectComposer`.
*   This pass takes the Scene output and composites the fog on top using the shader defined in 3.3.

### Step 5: Persistence (Save/Load)
*   Implement `TextureExtractor` equivalent for Three.js (using `renderer.readRenderTargetPixels`).
*   Hook into `FogManager` methods or replace `canvas.fog` references where necessary.

## 5. Technical Challenges & Solutions

*   **Coordinate Systems**: Foundry is (0,0) Top-Left. Three.js is (0,0) Center.
    *   *Solution*: The Vision Camera must be an OrthographicCamera matching the Foundry dimensions exactly, or we transform the meshes. Matching dimensions is easier for mapping textures 1:1.
*   **Performance**: Re-triangulating polygons every frame is slow.
    *   *Solution*: Only update geometry when `source.los` changes (monitor `source.version` or hooks). Use `InstancedMesh` if possible, though shapes vary wildly. Geometry pooling might be needed.
*   **Soft Edges**: Hard polygon edges look bad.
    *   *Solution*: Render vision meshes with a slight gradient texture on edges, or run a cheap Gaussian blur pass on the `visionTarget`.

## 6. API Hooks
We need to listen to:
*   `lightingRefresh`: Update light source meshes.
*   `sightRefresh`: Update vision source meshes.
*   `canvasReady`: Initialize textures.
*   `updateToken`: Update source positions.

## 7. Refinements (Advanced)
*   **Height/Elevation**: Foundry supports limited elevation in LOS. Since we are 2.5D, we might want to actually *render* the walls in the Vision Pass to create true occlusions if we ever move away from Foundry's calculated LOS. For now, sticking to Foundry's LOS is safer.
