# Mask Spaces Contract

## Purpose
This document defines the authoritative coordinate space and sampling rules for every shared mask texture in MapShine Advanced. It prevents coordinate space mismatches that cause visual artifacts (jitter, incorrect occlusion, distortion misalignment).

---

## Coordinate Spaces

### Scene UV Space
- **Origin**: Top-left of the scene rectangle (not including padding)
- **Range**: `(0, 0)` to `(1, 1)` covering the full scene
- **Y-axis**: Flipped (V=0 at top, V=1 at bottom) to match Foundry/PIXI convention
- **Use case**: World-space masks that need to stay pinned to the map
- **Sampling**: Use scene bounds uniforms to convert world coordinates to scene UV

### Screen UV Space
- **Origin**: Top-left of the screen/viewport
- **Range**: `(0, 0)` to `(1, 1)` covering the full render target
- **Y-axis**: Flipped (V=0 at top, V=1 at bottom) to match WebGL convention
- **Use case**: Screen-space effects (post-processing, overlays)
- **Sampling**: Use `gl_FragCoord / uScreenSize` or `vUv` (if quad is full-screen)

### World Space
- **Origin**: Bottom-left of the scene (Foundry convention inverted for Three.js)
- **Range**: Pixel coordinates in world units
- **Y-axis**: Up (Y increases upward)
- **Use case**: Particle systems, world-space meshes
- **Conversion to Scene UV**: `sceneUv = (worldPos - sceneMin) / sceneSize; sceneUv.y = 1.0 - sceneUv.y;`

### Foundry World Space
- **Origin**: Top-left of the scene (Foundry convention)
- **Range**: Pixel coordinates in Foundry units
- **Y-axis**: Down (Y increases downward)
- **Use case**: Interfacing with Foundry documents (tiles, tokens, walls)
- **Conversion to Three.js World**: `threeY = sceneHeight - foundryY`

---

## Mask Registry

### Base Plane Albedo (`_Albedo` / base texture)
- **Space**: Scene UV
- **Channels**: RGB (sRGB color)
- **Y-flip**: Yes (V=0 at top)
- **Mipmap**: Yes (LinearMipmapLinearFilter)
- **Color space**: sRGB
- **Generated by**: `SceneComposer` from background image or large tile
- **Sampled by**: Lighting, all surface effects
- **Notes**: This is the primary visible texture; all other masks are registered relative to this

### Outdoors Mask (`_Outdoors`)
- **Space**: Scene UV
- **Channels**: Red (luminance, 0=indoor, 1=outdoor)
- **Y-flip**: Yes (V=0 at top)
- **Mipmap**: No (LinearFilter)
- **Color space**: NoColorSpace (linear data)
- **Generated by**: `MaskManager` from tile/region data
- **Sampled by**: Lighting (indoor occlusion), weather (outdoor-only effects), fire (outdoor guttering)
- **Notes**: Determines whether a pixel is "under roof" or "in open air"

### Specular Mask (`_Specular`)
- **Space**: Scene UV
- **Channels**: Red (luminance, intensity of specular highlights)
- **Y-flip**: Yes (V=0 at top)
- **Mipmap**: No (LinearFilter)
- **Color space**: NoColorSpace (linear data)
- **Generated by**: `MaskManager` from tile mask or manual authoring
- **Sampled by**: SpecularEffect (PBR material)
- **Notes**: Controls where shiny/reflective surfaces appear

### Water Mask (`_Water`)
- **Space**: Scene UV
- **Channels**: Red (luminance, 0=no water, 1=water)
- **Y-flip**: Yes (V=0 at top)
- **Mipmap**: No (LinearFilter)
- **Color space**: NoColorSpace (linear data)
- **Generated by**: `MaskManager` from tile/region data
- **Sampled by**: WaterEffectV2 (water surface rendering), DistortionManager (water ripple distortion)
- **Notes**: Identifies water bodies for special rendering and physics

### Fire Mask (`_Fire`)
- **Space**: Scene UV
- **Channels**: Red (luminance, brightness of fire sources)
- **Y-flip**: Yes (V=0 at top)
- **Mipmap**: No (LinearFilter)
- **Color space**: NoColorSpace (linear data)
- **Generated by**: `MaskManager` from tile/region data or map points
- **Sampled by**: FireSparksEffect (particle placement), DistortionManager (heat haze)
- **Notes**: Determines fire particle density and heat distortion intensity

### Roof Alpha Map (Screen-space)
- **Space**: Screen UV
- **Channels**: Red (alpha, 0=transparent, 1=opaque roof)
- **Y-flip**: Yes (V=0 at top)
- **Mipmap**: No (LinearFilter)
- **Color space**: NoColorSpace (linear data)
- **Generated by**: `LightingEffect` pre-pass rendering overhead tiles
- **Sampled by**: Lighting shader (occlusion), distortion (masking)
- **Notes**: **CRITICAL**: This is screen-space, NOT world-space. Do NOT sample with world coordinates.

### Roof Outdoor Mask (`uRoofMap` / Outdoors for roofs)
- **Space**: Scene UV
- **Channels**: Red (luminance, 0=indoor under roof, 1=outdoor)
- **Y-flip**: Yes (V=0 at top)
- **Mipmap**: No (LinearFilter)
- **Color space**: NoColorSpace (linear data)
- **Generated by**: `WeatherController` from tile/region data
- **Sampled by**: Lighting shader (indoor light occlusion), weather effects
- **Notes**: Distinguishes "indoor under roof" from "outdoor under roof" for lighting behavior

### Normal Map (`_Normal`)
- **Space**: Scene UV
- **Channels**: RGB (normal vectors in tangent space)
- **Y-flip**: Yes (V=0 at top)
- **Mipmap**: No (LinearFilter)
- **Color space**: NoColorSpace (linear data)
- **Generated by**: `MaskManager` from tile mask or manual authoring
- **Sampled by**: Lighting shader (surface detail)
- **Notes**: Encodes surface detail for lighting calculations

### Iridescence Mask (`_Iridescence`)
- **Space**: Scene UV
- **Channels**: Red (luminance, intensity of iridescent effect)
- **Y-flip**: Yes (V=0 at top)
- **Mipmap**: No (LinearFilter)
- **Color space**: NoColorSpace (linear data)
- **Generated by**: `MaskManager` from tile mask
- **Sampled by**: IridescenceEffect (holographic shimmer)
- **Notes**: Controls where thin-film interference colors appear

### Window Light Mask (`_Windows` / `_Structural`)
- **Space**: Scene UV
- **Channels**: RGB (luminance, brightness of window light sources)
- **Y-flip**: Yes (V=0 at top)
- **Mipmap**: No (LinearFilter)
- **Color space**: NoColorSpace (linear data)
- **Generated by**: `MaskManager` from tile mask
- **Sampled by**: WindowLightEffect (indoor light pools)
- **Notes**: Identifies window/light source locations for projected lighting

### Roughness Mask (`_Roughness`)
- **Space**: Scene UV
- **Channels**: Red (luminance, 0=smooth, 1=rough)
- **Y-flip**: Yes (V=0 at top)
- **Mipmap**: No (LinearFilter)
- **Color space**: NoColorSpace (linear data)
- **Generated by**: `MaskManager` from tile mask
- **Sampled by**: Lighting shader (PBR material)
- **Notes**: Controls surface roughness for specular calculations

---

## Conversion Helpers

### Scene UV ↔ World Space

```glsl
// World to Scene UV
vec2 worldToSceneUv(vec3 worldPos, vec4 uSceneBounds, vec2 uSceneDimensions) {
  vec2 relPos = worldPos.xy - uSceneBounds.xy;
  vec2 uv = relPos / uSceneBounds.zw;
  uv.y = 1.0 - uv.y; // Flip Y
  return uv;
}

// Scene UV to World
vec3 sceneUvToWorld(vec2 uv, vec4 uSceneBounds, float worldZ) {
  vec2 flippedUv = vec2(uv.x, 1.0 - uv.y);
  vec2 worldXy = uSceneBounds.xy + flippedUv * uSceneBounds.zw;
  return vec3(worldXy, worldZ);
}
```

### Screen UV ↔ World Space (via camera reconstruction)

```glsl
// Screen UV to World (requires camera uniforms)
vec3 screenUvToWorld(vec2 screenUv, float depth, mat4 uInvProjection, mat4 uInvView) {
  vec4 ndc = vec4(screenUv * 2.0 - 1.0, depth * 2.0 - 1.0, 1.0);
  vec4 viewPos = uInvProjection * ndc;
  viewPos /= viewPos.w;
  vec4 worldPos = uInvView * viewPos;
  return worldPos.xyz;
}

// World to Screen UV (requires camera uniforms)
vec2 worldToScreenUv(vec3 worldPos, mat4 uProjection, mat4 uView) {
  vec4 viewPos = uView * vec4(worldPos, 1.0);
  vec4 clipPos = uProjection * viewPos;
  vec2 ndc = clipPos.xy / clipPos.w;
  return ndc * 0.5 + 0.5;
}
```

### Foundry World ↔ Three.js World

```javascript
// Foundry to Three.js
function foundryToThreeWorld(foundryX, foundryY, sceneHeight) {
  return {
    x: foundryX,
    y: sceneHeight - foundryY
  };
}

// Three.js to Foundry
function threeToFoundryWorld(threeX, threeY, sceneHeight) {
  return {
    x: threeX,
    y: sceneHeight - threeY
  };
}
```

---

## Common Mistakes & How to Avoid Them

### ❌ Mistake 1: Sampling roof alpha (screen-space) with world coordinates
```glsl
// WRONG - roof alpha is screen-space, not world-space
float roofAlpha = texture(uRoofAlphaMap, worldToSceneUv(worldPos, ...)).r;

// CORRECT - use screen UV
float roofAlpha = texture(uRoofAlphaMap, gl_FragCoord / uScreenSize).r;
```

### ❌ Mistake 2: Inconsistent Y-flip between masks
```glsl
// WRONG - mixing flipped and non-flipped UVs
vec2 uv1 = sceneUv; // Already flipped
vec2 uv2 = vec2(sceneUv.x, 1.0 - sceneUv.y); // Flipped again!
float val = texture(mask1, uv1).r + texture(mask2, uv2).r;

// CORRECT - use consistent UV
float val = texture(mask1, sceneUv).r + texture(mask2, sceneUv).r;
```

### ❌ Mistake 3: Sampling world-space mask with screen UV
```glsl
// WRONG - outdoors mask is world-space, not screen-space
float outdoor = texture(uOutdoorsMap, gl_FragCoord / uScreenSize).r;

// CORRECT - convert to scene UV first
vec2 sceneUv = worldToSceneUv(worldPos, uSceneBounds, uSceneDimensions);
float outdoor = texture(uOutdoorsMap, sceneUv).r;
```

### ❌ Mistake 4: Forgetting to disable mipmaps on data masks
```glsl
// WRONG - data mask with mipmaps causes aliasing/banding
texture.generateMipmaps = true;
texture.minFilter = THREE.LinearMipmapLinearFilter;

// CORRECT - data masks should use nearest or linear without mipmaps
texture.generateMipmaps = false;
texture.minFilter = THREE.LinearFilter;
```

---

## Validation & Testing

### Runtime Assertions (Debug Mode)
```javascript
// In effect initialize():
if (DEBUG_MODE) {
  const policy = getPolicyInfo('DATA_MASK');
  if (!validateTexturePolicy(maskTexture, 'DATA_MASK')) {
    console.warn('Mask texture does not match DATA_MASK policy!', maskTexture);
  }
}
```

### Shader Validation
- Add `#define DEBUG_MASK_SPACES 1` to enable debug visualization
- Render masks to screen to verify coordinate alignment
- Check for Y-flip inconsistencies by rendering checkerboard patterns

### Integration Tests
- Verify masks stay pinned to map during pan/zoom
- Verify roof alpha correctly occludes lighting during camera movement
- Verify fire particles spawn only on fire mask locations

---

## Future Improvements

1. **Automated Mask Discovery**: Scan all shaders for texture sampling and validate against this contract
2. **Mask Composition**: Define how multiple masks combine (e.g., outdoors + roof)
3. **Mask Lifecycle**: Document when masks are generated, updated, and disposed
4. **Performance**: Identify opportunities to pack multiple masks into single texture channels
